import cv2
import numpy as np
import sys

# Load the table image
image_path = '/Users/Ellaberg/Desktop/test.jpg'
image = cv2.imread(image_path)

# Create an array to store the cropped row images
row_images = []

# Define the correct answers
letters_list = ['A', 'B', 'C', 'D', 'D']

# Initialize a variable to keep track of the total points
total_points = 0

# Initialize a kernel for erosion (adjust the size as needed)
kernel = np.ones((5, 5), np.uint8)

# Initialize a variable to track the row number
row_number = 2  # Start from row 2

# Create a list to store positions where the difference is over 20
x_location = []

# Define the threshold value
threshold_value = 130

# Display the original image
cv2.imshow("Original Image", image)
cv2.waitKey(0)

# Preprocess the image
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
blurred = cv2.GaussianBlur(gray, (5, 5), 0)
 # Apply the threshold to the grayscale row image
_, thresh = cv2.threshold(blurred, threshold_value, 255, cv2.THRESH_BINARY)

# Display the thresholded row image
cv2.imshow("Thresholded Image", thresh)
cv2.waitKey(0) 

min_area_threshold = 1000

# Find contours in the blurred image
contours, _ = cv2.findContours(thresh, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)

# Filter and draw the contours
filtered_contours = []

for contour in contours:
    # Filter based on contour area
    area = cv2.contourArea(contour)
    if area > min_area_threshold:
        filtered_contours.append(contour)

# Draw the filtered contours on the original image
result_image = image.copy()
cv2.drawContours(result_image, filtered_contours, -1, (0, 255, 0), 2)

# Display the result
cv2.imshow('Contours', result_image)
cv2.waitKey(0)
cv2.destroyAllWindows()

# Filter and draw the contours for rows
min_row_height = 50
row_images = []

for contour in contours:
    x, y, w, h = cv2.boundingRect(contour)

    if h >= min_row_height:
        row_image = image[y:y+h, x:x+w]
        row_images.append([row_image,x,y])  # Insert the row at the beginning of the list

row_images.sort(key=lambda x:(x[2]))

if not len(row_images) == 67:
    print("Detection not possible")
    sys.exit()

sorted_images = []

for i in range(2,len(row_images)-2,5):
    if i == 2:
        pass
    else:
        nyliste = [row_images[i],row_images[i+1],row_images[i+2],row_images[i+3],row_images[i+4]]
        nyliste.sort(key=lambda x:(x[1]))
        nyliste.pop(0)

        for j in nyliste:
            print(j[1],j[2])
            sorted_images.append(j[0])


# Loop through the row images in the sorted order
for i, row_image in enumerate(sorted_images):
    # Display the current row image
    cv2.imshow(f"Row {i + 1} - Original Row Image", row_image)
    cv2.waitKey(0)


cv2.destroyAllWindows()










# The rest of your code for processing rows goes here




# Create a dictionary to map letters to their corresponding numeric values
letter_to_value = {'A': 1, 'B': 2, 'C': 3, 'D': 4}

# Sammenlikner fasiten med de innleste svarene
for i in range(len(x_location)):
    number_value = x_location[i]
    letter_value = letter_to_value.get(letters_list[i], 0)  # Default to 0 if the letter is not in the mapping

    # Compare the values and calculate the points
    if number_value == letter_value:
        points = 1
    elif number_value == 0 or letter_value == 0:
        points = 0
    else:
        points = -0.25

    total_points += points

# Print the total points
print(f"Total Points: {total_points}")
