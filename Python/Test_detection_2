import cv2
import numpy as np
import sys

# Load the table image
image_path = '/Users/Ellaberg/Desktop/ordentlig_test_tabell.jpg'
image = cv2.imread(image_path)

# Define the correct answers
letters_list = ['A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A']

# Initialize a variable to keep track of the total points
total_points = 0

# Initialize a kernel for erosion (adjust the size as needed)
kernel = np.ones((5, 5), np.uint8)

# Create an array to store the cropped row images
row_images = []

# Create a list to store positions where the difference is over 20
x_location = []

# Display the original image
cv2.imshow("Original Image", image)
cv2.waitKey(0)

# Define the threshold value
threshold_value = 70

# Preprocess the image
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
blurred = cv2.GaussianBlur(gray, (5, 5), 0)
 # Apply the threshold to the grayscale row image
_, thresh = cv2.threshold(blurred, threshold_value, 255, cv2.THRESH_BINARY)

# Display the thresholded row image
cv2.imshow("Thresholded Image", thresh)
cv2.waitKey(0) 

# Find contours in the blurred image
contours, _ = cv2.findContours(thresh, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)

# Filter and draw the contours
filtered_contours = []

min_area_threshold = 1000

for contour in contours:
    # Filter based on contour area
    area = cv2.contourArea(contour)
    if area > min_area_threshold:
        filtered_contours.append(contour)

# Draw the filtered contours on the original image
result_image = image.copy()
cv2.drawContours(result_image, filtered_contours, -1, (0, 255, 0), 2)

# Display the result
cv2.imshow('Contours', result_image)
cv2.waitKey(0)
cv2.destroyAllWindows()

# Filter and draw the contours for rows
min_row_height = 50
row_images = []

for contour in contours:
    x, y, w, h = cv2.boundingRect(contour)

    if h >= min_row_height:
        row_image = gray[y:y+h, x:x+w]
        row_images.append([row_image,x,y])  # Insert the row at the beginning of the list

row_images.sort(key=lambda x:(x[2]))

if not len(row_images) == 67:
    print("Detection not possible")
    sys.exit()

sorted_images = []

for i in range(2,len(row_images)-2,5):
    if i == 2:
        pass
    else:
        nyliste = [row_images[i],row_images[i+1],row_images[i+2],row_images[i+3],row_images[i+4]]
        nyliste.sort(key=lambda x:(x[1]))
        nyliste.pop(0)

        for j in nyliste:
            print(j[1],j[2])
            sorted_images.append(j[0])

# Loop through the sorted cell images
for i, row_image in enumerate(sorted_images):
    # Display the current row image
    cv2.imshow(f"Cell {i + 1} - Original", row_image)
    cv2.waitKey(0)

    # Thresholding the cells
    _, thresh_cell = cv2.threshold(row_image, 100, 255, cv2.THRESH_BINARY)
    cv2.imshow(f"Cell {i + 1} - Thresholded", thresh_cell)
    cv2.waitKey(0)

    # Apply erosion to the thresholded cell
    eroded_cell = cv2.erode(thresh_cell, kernel, iterations=5)

    # Calculate the average pixel value for the current row image
    average_value = np.mean(eroded_cell)
    print(f"Cell {i + 1} - Average Pixel Value: {average_value}")

    # Display the eroded cell
    cv2.imshow(f"Cell {i + 1} - Eroded", eroded_cell)
    cv2.waitKey(0)

    # Close the windows before moving on to the next set of images
    cv2.destroyAllWindows()
    cv2.waitKey(1)  # Add a small delay to make sure windows are closed

    # Loop through the sorted row images
for i in range(0, len(sorted_images), 4):
    group = sorted_images[i:i + 4]

    # Calculate the average pixel values for each image in the group
    average_values = [np.mean(cv2.erode(cell, kernel, iterations=5)) for cell in group]

    # Find the index with the lowest value
    min_index = np.argmin(average_values)

    # Check for differences over 20
    found_difference = False
    for j in range(len(average_values)):
        if j != min_index and abs(average_values[min_index] - average_values[j]) > 20:
            # Store the position of the image with the lowest pixel value (1, 2, 3, or 4)
            position = min_index + 1
            x_location.append(position)
            found_difference = True
            break  # No need to check further if a difference is found

    # Append zero if no pair has a difference over 20
    if not found_difference:
        x_location.append(0)

# Print the list of image positions with a difference over 30 or 0 if no difference
print("Image Positions with a Difference over 30 or 0 if No Difference:", x_location)


cv2.destroyAllWindows()

# Create a dictionary to map letters to their corresponding numeric values
letter_to_value = {'A': 1, 'B': 2, 'C': 3, 'D': 4}

# Sammenlikner fasiten med de innleste svarene
for i in range(len(x_location)):
    number_value = x_location[i]
    letter_value = letter_to_value.get(letters_list[i], 0)  # Default to 0 if the letter is not in the mapping

    # Compare the values and calculate the points
    if number_value == letter_value:
        points = 1
    elif number_value == 0 or letter_value == 0:
        points = 0
    else:
        points = -0.25

    total_points += points

# Print the total points
print(f"Total Points: {total_points}")
